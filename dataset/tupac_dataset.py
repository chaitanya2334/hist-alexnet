import glob
import os
from collections import defaultdict, namedtuple, Counter
from random import shuffle, sample
from sys import stdout, stderr

import cv2
import itertools

import torch
from numpy.linalg import LinAlgError
from torch.utils import data
from tqdm import tqdm
import csv_utils
import numpy as np

from postprocessing.visualizers.draw_roi import TileVisualizer

Sample = namedtuple("Sample", ["image", "label", "img_path"])


class TUPACDataset(data.Dataset):
    class CustomDataset(data.Dataset):
        def __init__(self, path_label_pair, label_2_id, transform=None):
            self.path_label_pair = path_label_pair
            self.transform = transform
            self.label_2_id = label_2_id

        def get_sample_weights(self):
            labels = [label for _, label in self.path_label_pair]
            c = Counter(labels)
            weights = list(c.values())
            weights = [1.0 / c for c in weights]
            sample_weights = [weights[label] for _, label in self.path_label_pair]
            return sample_weights

        def __getitem__(self, item):
            filepath, lbl_idx = self.path_label_pair[item]
            image = cv2.imread(filepath)
            lbl_idx = self.label_2_id[lbl_idx]
            if self.transform is not None:
                try:
                    image = self.transform(image)
                except LinAlgError as e:
                    print(e, file=stderr)
                    print("Array must not contain infs or NaNs. "
                          "filepath = {0}, label = {1}".format(filepath, lbl_idx), file=stderr)
                    stderr.flush()

            return Sample(image, lbl_idx, filepath)

        def __len__(self):
            return len(self.path_label_pair)

        def count_labels(self):
            labels = [label for _, label in self.path_label_pair]
            c = Counter(labels)
            return c.values()

    def __init__(self, wsi_dir, tiles_dir, label_dir, label_2_id, mu, std, tile_size=224,
                 split=(90, 5, 5), balance_ratio=(1, 2), randomize=True, transform=None, pre_visualize=False,
                 vis_dir=None):

        self.dir_status_file = ".dir_status"
        self.tile_size = tile_size
        self.randomize = randomize
        self.tiles_dir = tiles_dir
        self.mu = mu
        self.std = std

        self.split = split

        self.label_dir = label_dir

        # label_2_id = {benign:0, normal:1 ...}
        self.label_2_id = label_2_id

        #  glob.iglob(path + '/**/*' + img_ext, recursive=True)
        img_paths = sorted(glob.iglob(os.path.join(self.tiles_dir, "**", "*.png"), recursive=True),
                           key=os.path.getmtime)

        print("  Generating labels ...")
        labels = [self.gen_label(path) for path in tqdm(img_paths, desc="generating labels")]

        self.transform = transform

        # d = {label1: [img_paths], label2: [img_paths] ...}
        d = self.__gen_bins(zip(labels, img_paths))

        tr, dev, te = self.__create_tdt(d, balance_ratio=balance_ratio)

        self.te = te

        vis = TileVisualizer(wsi_dir=wsi_dir,
                             save_dir=vis_dir,
                             pos_label="mitosis",
                             neg_label="no-mitosis",
                             tile_size=tile_size)

        if pre_visualize:
            img_paths, labels = zip(*tr)
            # TODO come up with a better strat for visualizing just the true labels
            # vis.visualize(labels, img_paths, show_pos=True, show_neg=True)

    # balance pos and neg examples in the full dataset.
    # dataset generated by this function is always !RANDOM! (the negative samples specifically).
    # !Only works with 2 labels!
    @staticmethod
    def balance_dataset(d, labels, ratio):
        # Step. 1: bin all the tiles by their wsi name
        pos_label = labels[0]
        neg_label = labels[1]
        print("Balancing dataset by randomly sampling pos_label: {0} and neg_label: {1} using ratio: {2}".format(
            pos_label, neg_label, ratio))
        _bin = {}

        for tile_path, label in tqdm(d, desc="balancing dataset"):
            wsi_path = os.path.dirname(tile_path)
            if wsi_path not in _bin:
                _bin[wsi_path] = []

            _bin[wsi_path].append((tile_path, label))

        ret = []

        # Step. 2: randomly sample positive and negative examples to balance the dataset
        for wsi_path, tiles in _bin.items():
            # we always take all of the positive tiles

            pos_tiles = [(tp, lbl) for tp, lbl in tiles if lbl == pos_label]
            neg_tiles = [(tp, lbl) for tp, lbl in tiles if lbl == neg_label]

            # randomly sample negative samples based on the ratio.
            if len(neg_tiles) > ratio[1] * len(pos_tiles):
                neg_tiles = sample(neg_tiles, ratio[1] * len(pos_tiles))

            ret.extend(pos_tiles + neg_tiles)

        return ret

    @staticmethod
    def __gen_bins(k_v_pairs):
        dd = defaultdict(list)
        for k, v in tqdm(k_v_pairs, desc="binning pairs"):
            dd[k].append(v)

        return dd

    @staticmethod
    def batchify(samples):
        images = [sample.image for sample in samples if sample]
        images = torch.stack(images, dim=0)
        labels = [sample.label for sample in samples if sample]
        img_paths = [sample.img_path for sample in samples if sample]
        return images, labels, img_paths

    def gen_label(self, path, pos_label="mitosis", neg_label="no-mitosis"):
        # assuming path = <root>/<img_id>/<img_name>.png
        # ex path = root/01/0-101.png
        # path = <root>/tiles/12/04/0-600-90.png
        img_id = os.path.dirname(path).replace(self.tiles_dir + '/', '')
        # img_id = 12/04
        try:
            x, y, r = os.path.basename(os.path.splitext(path)[0]).split('-')
        except:
            print(path)
        # x = 0, y = 600, r = 90
        lbl_path = os.path.join(self.label_dir, img_id + ".csv")
        # lbl_path = <root>/labels/12/04.csv
        true_labels = []
        if os.path.isfile(lbl_path):
            true_labels = csv_utils.read(lbl_path, is_headers=False)

        # TODO verify row columns for label file
        labels = [(int(row[0]), int(row[1])) for row in true_labels]
        # labels = [(70, 1782)]
        for label in labels:
            if (int(x) < int(label[0]) <= int(x) + self.tile_size) and \
                    (int(y) < int(label[1]) <= int(y) + self.tile_size):
                return pos_label

        return neg_label

    @staticmethod
    def __split(per, bins):
        res = ([], [], [])
        assert sum(per) == 100
        print(res)
        for k, l in tqdm(bins.items(), desc="splitting dataset"):
            size = len(l)
            print("label: {0}, size: {1}".format(k, len(l)))
            cum_per = 0
            prv = 0
            for i, p in enumerate(per):
                cum_per += p
                nxt = int((cum_per / 100) * size)
                res[i].extend([(val, k) for val in l[prv:nxt]])
                print(len(res[0]), len(res[1]), len(res[2]))
                prv = nxt

        return res

    def validate_tiles(self, path_label_pairs):
        to_del = []
        for i, (path, label) in enumerate(tqdm(path_label_pairs, desc="validating tiles")):
            try:
                image = cv2.imread(path)
                image = self.transform(image)
            except:
                to_del.append(i)

        for index in sorted(to_del, reverse=True):
            del path_label_pairs[index]

        return path_label_pairs

    def __create_tdt(self, img_path_dict, balance_ratio):
        # img_path_dict = {label1: [img_paths], label2: [img_paths] ...}

        # get image metadata for each image in the training and test directories
        tr, dev, te = self.__split(self.split, img_path_dict)
        # create a Dataset object for each train, dev and test.
        labels = list(self.label_2_id.keys())

        tr, dev, te = (self.balance_dataset(d, labels, balance_ratio)
                       for d in (tr, dev, te))

        self.train, self.dev, self.test = (self.CustomDataset(d, self.label_2_id, self.transform)
                                           for d in (tr, dev, te))

        self.full = self.CustomDataset(img_path_dict, self.label_2_id, self.transform)

        return tr, dev, te

    @staticmethod
    def _label_by_id(labels, img_id):

        for row in labels:
            if row['id'] == img_id:
                return row['id'], row['label']

        return None, None
